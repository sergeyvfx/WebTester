/**
 * WebTester Server - server of on-line testing system
 *
 * Testing module for simple olympiands
 *
 * Copyright 2008 Sergey I. Sharybin <g,ulairi@gmail.com>
 *
 * This program can be distributed under the terms of the GNU GPL.
 * See the file COPYING.
 */

#include "informatics.h"
#include "macros.h"

#include <libwebtester/smartinclude.h>
#include <libwebtester/dynastruc.h>
#include <libwebtester/conf.h>
#include <libwebtester/flexval.h>
#include <libwebtester/strlib.h>
#include <libwebtester/regexp.h>
#include <libwebtester/util.h>
#include <libwebtester/fs.h>
#include <libwebtester/mutex.h>

#include <librun/run.h>

#include <testlib/testlib.h>

#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>

/* MAX count of tests */
#define MAX_TESTS      1024
#define MAX_ERRCODE    2

#define MAX_COMPILER_MSG_LEN 4096

/* File to print solution's testing info */
#define SOLUTION_ERRORS_LOG "errors.log"

/****
 * Macroses
 */

/* Crash in testing loop */
#define LOOPCRASH \
  (*__points)=0; \
  strcpy (__errors, "CR"); \
  CR=TRUE; \
  goto __done_;

/* Push error of current test */
#define ERR(__err, __s) \
  { \
    __err=TRUE; \
    strcpy (cur_err_str, __s); \
    push_string (__s, " ", tests_res_pchar); \
    /* If rules are ACM we needn't run solution in next tests */ \
    if (acm) { \
      unlink (full_input); \
      unlink (full_output); \
      LOG_TEST; \
      goto __done_; \
    } \
  }

/* Log result of currebt test */
#define LOG_TEST \
  TASK_LOG (*__self, "  Test #%d: %s\n", i+1, cur_err_str);

/* Check module's active in testing loop */
#define LOOP_CHECK_ACTIVE \
  if (mutex_trylock (active)) \
    { \
      mutex_unlock (active); \
      goto __done_; \
    }

/* Check module's active after testing loop */
#define LOOP_DONE_CHECK_ACTIVE \
  if (mutex_trylock (active)) \
    { \
      mutex_unlock (active); \
      /* Checking has been interrupted. */ \
      /* So there is nothing interesting in testing dir. */ \
      unlinkdir (__cur_testing_dir); \
      return; \
    }

/* Check module's active in main testing thread */
#define TESTING_CHECK_ACTIVE \
  if (mutex_trylock (active)) \
    { \
      mutex_unlock (active); \
      goto __free_; \
    }

#ifdef INFORMATICS_ENABLE_REPORT
#  define REPORT(__params,__text,__args...) \
  { \
    char sbuf[4096], buf[4096]; \
    sprintf (buf, __text, ##__args); \
    strcpy (sbuf, ""); \
    if (assarr_get_value (__params, "REPORT")) \
      { \
        strcat (sbuf, assarr_get_value (__params, "REPORT")); \
        assarr_unset_value (__params, "REPORT", assarr_deleter_free_ref_data); \
      } \
    strcat (sbuf, buf); \
    assarr_set_value (__params, "REPORT", strdup (sbuf)); \
  }
#else
#  define REPORT(__params,__text,__args...)
#endif

#define TASK_SRCEXT(__self) \
  COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self), \
                           "Extension", INFORMATICS_SRCEXT)

/****
 *
 */

static char log_banner[] = "\
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\
 This file is automatically generated by module Informatics\n\
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n\n";

/****
 *
 */

static DWORD checker_memory_limit = INFORMATICS_CHECKER_RSS_LIMIT;
static DWORD checker_time_limit = INFORMATICS_CHECKER_TIME_LIMIT*USEC_COUNT;
static GThreadPool *pool = NULL;
static GMutex *active = NULL;
static long max_threads = INFORMATICS_MAX_THREADS;

static char testing_dir[4096];
static char data_dir[4096];
static char problems_dir[4096];
static char source_file[4096];
static char file_to_exec[4096];

static char checker_cmd_template[4096];

static DWORD unlink_interval = INFORMATICS_UNLINK_INTERVAL*USEC_COUNT;
static long keep_alive_testdirs = INFORMATICS_KEEP_ALIVE_TESTDIRS;
static GMutex *unlink_mutex = NULL;

/* Extensions of input and output tests' filenames */
static char tst_ext[128];
static char ans_ext[128];

static long solution_exec_uid = -1;
static long solution_exec_gid = -1;
static char solution_exec_user[4096] = "";
static char solution_exec_group[4096] = "";

static BOOL use_chroot = FALSE;

static mutex_t suspended = 0;

/* Null-terminated list of required input task's params */
static char *required_params[] ={"SOURCE",
  "COMPILERID",
  "BONUS",
  "INPUTFILE",
  "OUTPUTFILE",
  "MEMORYLIMIT",
  "TIMELIMIT",
  "ACM",
  "TESTS",
  0};

static char chroot_items[64][64] = {
  {0}};

/****
 * Internal stuff
 */

/**
 * Copy all files needed for correct working after chrooting
 *
 * @param __dst_dir - where files should be copied
 */
static void
copy_chroot_data (const char *__dst_dir)
{
  char src_dir[4096];
  static char init = FALSE;

  INF_DEBUG_LOG ("Copying chroot data to %s\n", __dst_dir);

  sprintf (src_dir, "%s/chroot", data_dir);
  fcopydir (src_dir, __dst_dir);

  sprintf (src_dir, "%s/chroot", data_dir);

  if (!init)
    {
      /* Cache list of items, needed by chrooting */
      dynastruc_t *ls;
      int count = 0;
      char *cur_dir;
      ls = dir_listing (src_dir);

      DYNA_FOREACH (ls, cur_dir);
        strcpy (chroot_items[count++], cur_dir);
      DYNA_DONE;

      dyna_destroy (ls, dyna_deleter_free_ref_data);
      init = TRUE;
    }
}

/**
 * Remove all files needed for correct working after chrooting
 * from solution directory
 *
 * @param __dir - where files should be deleted
 */
static void
remove_chroot_data (const char *__dir)
{
  int i = 0;
  char full[4096];

  INF_DEBUG_LOG ("Removing chroot data from %s\n", __dir);

  while (chroot_items[i][0])
    {
      sprintf (full, "%s/%s", __dir, chroot_items[i]);
      unlinkdir (full);
      i++;
    }
}

/**
 * Push string to another separating from existing content
 *
 * @param __item - item to be pushed
 * @param __delimeter - separator of items
 * @param __buf - output buffer
 */
static void
push_string (const char *__item, const char *__delimeter, char *__buf)
{
  if (strcmp (__buf, ""))
    {
      strcat (__buf, __delimeter);
    }
  strcat (__buf, __item);
}

/**
 * Replace default variables in string
 *
 * @param __str - string to be replaced
 * @param __cur_testing_dir - current testing directpry
 * @param __cur_data_dir - directpry with current data files
 */
static void
replace_defaults (char *__str, const char *__cur_testing_dir,
                  const char *__cur_data_dir)
{
  REPLACE_VAR (__str, "testing_dir", testing_dir);
  REPLACE_VAR (__str, "data_dir", data_dir);
  REPLACE_VAR (__str, "cur_testing_dir", __cur_testing_dir);
  REPLACE_VAR (__str, "cur_data_dir", __cur_data_dir);
}

/**
 * PChar-ed number of test
 *
 * @param __num - number of current test
 * @param __total - total count of tests
 * @param __buf - output buffer
 */
static void
testnum (int __num, int __total, char *__buf)
{
  if (__total < 100)
    {
      sprintf (__buf, "%02d", __num);
    }
  else
    {
      sprintf (__buf, "%03d", __num);
    }
}

/**
 * Save solution to file
 *
 * @param __self - testing task
 * @param __cur_testing_dir - current testing directory
 * @return TRUE if solution saved, FALSE otherwise
 */
static BOOL
save_solution (wt_task_t *__self, char *__cur_testing_dir)
{
  char fn[4096];
  char *src = TASK_INPUT_PARAM (*__self, "SOURCE");

  sprintf (fn, "%s/%s%s", __cur_testing_dir,
           source_file, TASK_SRCEXT (__self));

  /* Write data to stream */
  if (fwritebuf (fn, src))
    {
      INF_DEBUG_LOG ("Task %ld. Error writting buffer to solution file\n",
                     __self->sid);
      return FALSE;
    }

  chmod (fn, 00660);

  return TRUE;
}

/******
 * Compiling stuff
 */

/**
 * Get command to compile solution
 *
 * @param __self - task to be compoled
 * @param __cur_testing_dir - current testing directory
 * @param __cur_data_dir - directory with current data
 * @para, __cmd - output buffer
 */
static void
build_compiler_command (wt_task_t *__self, const char *__cur_testing_dir,
                        const char *__cur_data_dir, char *__cmd)
{
  char dummy[4096], flags[4096] = "", flags_path[1024];

  /* Get command from config file */
  strcpy (__cmd, COMPILER_PCHAR_KEY (TASK_COMPILER_ID (*__self), "Command"));

  sprintf (flags_path, "CompilerFlags/%s", TASK_COMPILER_ID (*__self));
  INF_PCHAR_KEY (flags, flags_path);

  /* Parse command */
  replace_defaults (__cmd, __cur_testing_dir, __cur_data_dir);
  REPLACE_VAR (__cmd, "flags", flags);

  /* Source filename */
  sprintf (dummy, "%s%s", source_file, TASK_SRCEXT (__self));
  REPLACE_VAR (__cmd, "source", dummy);

  /* Output filename */
  sprintf (dummy, "%s%s", file_to_exec,
           COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self),
                                    "OutputExtension", INFORMATICS_EXECEXT));
  REPLACE_VAR (__cmd, "output", dummy);
}

/**
 * Run compiler with profiling
 *
 * @paxram __self - task to be compiled
 * @param __cmd - command to execute
 * @param __cur_testing_dir - current testing directory
 * @param __cur_data_dir - directory with current data
 * @oaram __params - collecting params to return to WebIFACE
 * @return TRUE on success, FALSE otherwise
 */
static BOOL
run_compiler (wt_task_t *__self, const char *__cmd,
              const char *__cur_testing_dir, const char *__cur_data_dir,
              assarr_t *__params)
{
  DWORD compiler_ml, compiler_tl, common_compiler_ml, common_compiler_tl;
  run_process_info_t *proc;
  BOOL result = TRUE;

  /* Get compiler's limits */
  common_compiler_ml = COMPILER_SAFE_COMMON_INT_KEY ("Limits/RSS",
                                               INFORMATICS_COMPILER_RSS_LIMIT);
  common_compiler_tl = COMPILER_SAFE_COMMON_FLOAT_KEY ("Limits/Time",
                                              INFORMATICS_COMPILER_TIME_LIMIT);

  compiler_ml = COMPILER_SAFE_INT_KEY (TASK_COMPILER_ID (*__self),
                                       "Limits/RSS", common_compiler_ml);
  compiler_tl = COMPILER_SAFE_FLOAT_KEY (TASK_COMPILER_ID (*__self),
                               "Limits/Time", common_compiler_tl) * USEC_COUNT;

  /* Create process */
  INF_DEBUG_LOG ("Task %ld. Executing compiler (cmd: %s)\n",
                 __self->sid, __cmd);

  proc = run_create_process (__cmd, __cur_testing_dir,
                             compiler_ml, compiler_tl);

  run_execute_process (proc); /* Execute process and.. */
  run_pwait (proc); /* ..wait finishing of process */
  INF_DEBUG_LOG ("Task %ld. Finish executing compiler\n", __self->sid);

  if (RUN_PROC_EXEC_ERROR (*proc))
    {
      INF_DEBUG_LOG ("Task %ld. Executing compiler failed: %s\n",
                     __self->sid, RUN_PROC_ERROR_DESC (*proc));
      TASK_LOG (*__self, "\n--------\n"
                         "Fatal error: error executing compiler: %s.\n"
                         "Testing aborted.\n", RUN_PROC_ERROR_DESC (*proc));
      REPORT (__params, "Error executing compiler: %s.", RUN_PROC_ERROR_DESC (*proc));
      run_free_process (proc);
      return -1;
    }

  /* Set output buffer from pipe */
  if (RUN_PROC_PIPEBUF (*proc))
    {
      char *pchar = strdup (RUN_PROC_PIPEBUF (*proc));

      if (strlen (pchar) > MAX_COMPILER_MSG_LEN)
        {
          pchar[MAX_COMPILER_MSG_LEN - 4] = 0;
          strcat (pchar, "...");
        }
      assarr_set_value (__params, "COMPILER_MESSAGES", pchar);
    }

  /* Nonzero-coded exit - compilation error */
  if (PROCESS_RUNTIME_ERROR (*proc))
    {
      result = FALSE;
    }

  run_free_process (proc);

  return result;
}

/**
 * Checking, casted after running compiler
 *
 * @param __self - task to be compiled
 * @param __cur_testing_dir - current testing directory
 * @param __cur_data_dir - directory with current data
 * @oaram __params - collecting params to return to WebIFACE
 * @return TRUE on success, FALSE otherwise
 */
static BOOL
post_compiling_check (wt_task_t *__self, const char *__cur_testing_dir,
                      const char *__cur_data_dir, assarr_t *__params)
{
  char pchar[4096];

  /* Check for existment of solution executable file */
  /* Get full filename of executable file */
  sprintf (pchar, "%s/%s%s", __cur_testing_dir, file_to_exec,
           COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self),
                                    "OutputExtension", ""));

  if (!fexists (pchar))
    {
      return FALSE;
    }

  chmod (pchar, 00775);

  return TRUE;
}

/**
 * Compile solution
 *
 * @param __self - task to be compiled
 * @param __cur_testing_dir - current testing directory
 * @param __cur_data_dir - directory with current data
 * @oaram __params - collecting params to return to WebIFACE
 * @return TRUE on success, FALSE or value less than zero in case of error
 */
static BOOL
compile_solution (wt_task_t *__self, const char *__cur_testing_dir,
                  const char *__cur_data_dir, assarr_t *__params)
{
  char cmd[32768];

  /* Generate command */
  strcpy (cmd, "");
  build_compiler_command (__self, __cur_testing_dir, __cur_data_dir, cmd);
  assarr_set_value (__params, "COMPILER_COMMAND", strdup (cmd));

  /* Compile command not defined */
  if (!strcmp (cmd, ""))
    {
      INF_DEBUG_LOG ("Task %ld. Compiler's command is undefined\n",
                     __self->sid);
      TASK_LOG (*__self, "\n--------\nFatal error: Compiler command is "
                         "undefined.\nTesting aborted.\n");
      REPORT (__params, "Compiler command is undefined.");

      return -1;
    }

  if (!run_compiler (__self, cmd, __cur_testing_dir, __cur_data_dir, __params))
    {
      return FALSE;
    }

  /* Some more checking */
  return post_compiling_check (__self, __cur_testing_dir,
                               __cur_data_dir, __params);
}

/****
 *
 */

/**
 * Copy test to testing directory
 *
 * @param __num - number of test to copy
 * @param __total - total count of tests
 * @param __data_dir - data directory
 * @param __dst - destination directory
 * @param __name - name of file to store to
 * @return TRUE on success, FALSE otherwise
 */
static BOOL
copy_test (int __num, int __total, const char *__data_dir,
           const char *__dst, const char *__name)
{
  char src[4096], dst[4096], tst[16];

  /* Get full source filename */
  testnum (__num, __total, tst);
  sprintf (src, "%s/%s%s", __data_dir, tst, tst_ext);

  /* Check for existment of test file */
  if (!fexists (src))
    {
      return FALSE;
    }

  /* Get full destination filename */
  sprintf (dst, "%s/%s", __dst, __name);

  if (copyfile (src, dst))
    {
      INF_DEBUG_LOG ("Error copuing test file from %s to %s\n", src, dst);
      return FALSE;
    }

  return TRUE;
}

/*
 * Build command to run checker
 *
 * @param __self - task to be compiled
 * @param __cur_testing_dir - current testing directory
 * @param __cur_data_dir - directory with current data
 * @param __test_num - number of curretn test
 * @para, __tests_count - count of tests
 * @return TRUE on success, FALSE otherwise
 */
static void
build_checker_cmd (wt_task_t *__self, const char *__cur_testing_dir,
                   const char *__cur_data_dir, int __test_num,
                   int __tests_count, char *__out)
{
  char atest[16]; /* PChar-ed number of test */
  char *input_file = TASK_INPUT_PARAM (*__self, "INPUTFILE");
  char *output_file = TASK_INPUT_PARAM (*__self, "OUTPUTFILE");

  testnum (__test_num, __tests_count, atest);

  strcpy (__out, checker_cmd_template);

  replace_defaults (__out, __cur_testing_dir, __cur_data_dir);

  REPLACE_VAR (__out, "test", atest);
  REPLACE_VAR (__out, "input_file", input_file);
  REPLACE_VAR (__out, "output_file", output_file);
}

/****
 *
 */

/*
 * Main stuff of testing
 *
 * @param __self - task to be compiled
 * @param __cur_testing_dir - current testing directory
 * @param __points - collected points
 * @param __errors - solution's errors on tests
 * @oaram __params - collecting params to return to WebIFACE
 */
static void
testing_main_loop (wt_task_t *__self, const char *__cur_data_dir,
                   const char *__cur_testing_dir, int *__points,
                   char *__errors, assarr_t *__params)
{
  int i;

  INF_DEBUG_LOG ("Task %ld. Enter testing mainloop stuff\n", __self->sid);

  /* Bonus points (if all tests passed) */
  int bonus = atoi (TASK_INPUT_PARAM (*__self, "BONUS"));

  /* I/O filenames  */
  /* Name of input file */
  char *input_file = TASK_INPUT_PARAM (*__self, "INPUTFILE");
  /* Name of output file  */
  char *output_file = TASK_INPUT_PARAM (*__self, "OUTPUTFILE");

  /* Resource limits */
  /* But why simple atof doesn't work? */
  DWORD memory_limit = flexval_atolf (TASK_INPUT_PARAM (*__self,
                                               "MEMORYLIMIT")) * 1024; /* Kb */
  DWORD time_limit = flexval_atolf (TASK_INPUT_PARAM (*__self,
                                        "TIMELIMIT")) * USEC_COUNT; /* usecs */

  char full_input[4096],  /* Full input filename */
       full_output[4096], /* Full output filename */
       checker_cmd[4096]; /* Command to execute */

  /* String with all tests' results */
  char tests_res_pchar[(MAX_ERRCODE + 1) * MAX_TESTS];

  /* Process's descriptor */
  run_process_info_t *proc = NULL;

  /* Filename to execute */
  char execfn[4096] = {0};

  /* Errors */
  BOOL RE = FALSE, ML = FALSE, TL = FALSE, WA = FALSE, PE = FALSE, CR = FALSE;
  /* PChar-ed error for current test */
  char cur_err_str[MAX_ERRCODE + 1];
  BOOL acm = !strcmp (TASK_INPUT_PARAM (*__self, "ACM"), "TRUE");

  /* Unpack tests' data */
  char *tests_pchar = TASK_INPUT_PARAM (*__self, "TESTS"),
          effective_tests[4096];

  char **tests_pchar_arr = 0;

  /* Points for tests */
  int tests[MAX_TESTS];

  /* Dummy pchar value */
  char dummy[1024];

  int compiler_chroot = COMPILER_SAFE_INT_KEY (TASK_COMPILER_ID (*__self),
                                              "ChRoot", -1);

  /* Get command for solution executing */
  char *run_solution_cmd = COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self),
                                                    "RunSolutionCmd", NULL);

  if (run_solution_cmd && strcmp (run_solution_cmd, ""))
    {
      /* We'll make some changes in this string, so we should */
      /* close this string to make original stored in hive tree */
      /* for correct freeing */
      run_solution_cmd = strdup (run_solution_cmd);

      /* String may be enlarged when parameters will be substitued  */
      run_solution_cmd = realloc (run_solution_cmd, 65535);

      replace_defaults (run_solution_cmd, __cur_testing_dir, __cur_data_dir);
    }

  /*
   * TODO: Need to strip dupicated spaces in source string with tests
   */

  trim (tests_pchar, effective_tests);
  int tests_count = explode (effective_tests, " ", &tests_pchar_arr);

  /* Per-compiler resource usage correction */
  double time_corr, rss_corr;

  for (i = 0; i < tests_count; i++)
    {
      tests[i] = atoi (tests_pchar_arr[i]);
    }

  /* Free unwanted data */
  free_explode_data (tests_pchar_arr);

  /* Some more initializations */
  sprintf (full_input, "%s/%s", __cur_testing_dir, input_file);
  sprintf (full_output, "%s/%s", __cur_testing_dir, output_file);

  strcpy (tests_res_pchar, "");

  TASK_LOG (*__self, "----\n");

  /* Get executable file name */
  INF_PCHAR_KEY (execfn, "FileToExec");
  strcat (execfn, COMPILER_SAFE_PCHAR_KEY (TASK_COMPILER_ID (*__self),
                                           "OutputExtension", ""));
  if (run_solution_cmd)
    {
      REPLACE_VAR (run_solution_cmd, "executable", execfn);
    }
  else
    {
      run_solution_cmd = strdup (execfn);
    }

  if (compiler_chroot >= 0)
    {
      use_chroot = compiler_chroot;
    }

  /* Copying all libs/binaries needed for correct running of solution */
  if (use_chroot)
    {
      copy_chroot_data (__cur_testing_dir);
    }

  /* Get corrections to apply when executing solution */
  sprintf (dummy, "ResourceCorrections/Compilers/%s/Time",
           TASK_COMPILER_ID (*__self));
  INF_SAFE_FLOAT_KEY (time_corr, dummy, 0);

  sprintf (dummy, "ResourceCorrections/Compilers/%s/RSS",
           TASK_COMPILER_ID (*__self));
  INF_SAFE_FLOAT_KEY (rss_corr, dummy, 0);

  /* Apply corrections */
  time_limit += time_corr * USEC_COUNT;
  memory_limit += rss_corr;

  if (fabs (time_corr) > 1e-8 || fabs (rss_corr) > 1e-8)
    {
      INF_DEBUG_LOG ("Using per-compiler corrections: RSS: %lf, time: %lf\n",
                     rss_corr, time_corr);
    }

  /* Cycle by tests */
  INF_DEBUG_LOG ("Task %ld. Begin cycle by tests\n", __self->sid);
  for (i = 0; i < tests_count; i++)
    {
      LOOP_CHECK_ACTIVE;

      /* Some pre-initialization */
      strcpy (cur_err_str, "OK");

      /* Command to execute checker */
      build_checker_cmd (__self, __cur_testing_dir, __cur_data_dir,
                         i + 1, tests_count, checker_cmd);

      /* Copy test file (input file) */
      INF_DEBUG_LOG ("Task %ld. Copy test\n", __self->sid);
      if (!copy_test (i + 1, tests_count, __cur_data_dir,
                      __cur_testing_dir, input_file))
        {
          TASK_LOG (*__self, "\n--------\n"
                             "Fatal error: error copying test file #%d.\n"
                             "Testing aborted.\n", i + 1);
          REPORT (__params, "Error copying test #%d.", i + 1);
          LOOPCRASH;
        }

      /* Execute solution */
      SAFE_FREE_PROC (proc);
      INF_DEBUG_LOG ("Task %ld. Executing solution (cmd: %s)\n",
                     __self->sid, run_solution_cmd);
      proc = run_create_process (run_solution_cmd, __cur_testing_dir,
                                 memory_limit, time_limit);

      /* Set security info */
      run_set_usergroup (proc, solution_exec_uid, solution_exec_gid);
      run_set_chroot (proc, use_chroot);

      run_execute_process (proc);
      run_pwait (proc);
      INF_DEBUG_LOG ("Task %ld. Finish executing solution\n", __self->sid);

      LOOP_CHECK_ACTIVE;

      if (RUN_PROC_EXEC_ERROR (*proc))
        {
          INF_DEBUG_LOG ("Task %ld. "
                         "Fatal error duting executing solution: %s\n",
                         __self->sid, RUN_PROC_ERROR_DESC (*proc));

          TASK_LOG (*__self, "\n--------\n"
                             "Fatal error: error executing solution "
                             "at test #%d: %s.\nTesting aborted.\n",
                    i + 1, RUN_PROC_ERROR_DESC (*proc));

          REPORT (__params, "Error executing solution at test #%d: %s.",
                  i + 1, RUN_PROC_ERROR_DESC (*proc));

          LOOPCRASH;
        }

      INF_DEBUG_LOG ("Task %ld test #%d: solution exit with exit_code %d, "
                     "rss_usage %lld and time_usage %lld\n", __self->sid, i,
                     RUN_PROC_EXITCODE (*proc), RUN_PROC_RSSUSAGE (*proc),
                     RUN_PROC_TIMEUSAGE (*proc));

      if (RUN_PROC_PIPEBUF (*proc))
        {
          INF_DEBUG_LOG ("Pipe from task %ld test #%d: %s\n", __self->sid, i,
                         RUN_PROC_PIPEBUF (*proc));
        }

      /* Overview solution's status */
      if (RUN_PROC_MEMORYLIMIT (*proc))
        {
          ERR (ML, "ML")
        }
      else if (RUN_PROC_TIMELIMIT (*proc))
        {
          ERR (TL, "TL")
        }
      else if (PROCESS_RUNTIME_ERROR (*proc))
        {
          ERR (RE, "RE")
        }
      else
        {
          if (!fexists (full_output))
            {
              /* No output file. Presentation error. */
              ERR (PE, "PE");
              INF_DEBUG_LOG ("Task %ld. Output file not found after "
                             "running solution.", __self->sid);
            }
          else
            {
              /* Exec checker */
              SAFE_FREE_PROC (proc);
              INF_DEBUG_LOG ("Task %ld. Executing checker (cmd: %s)\n",
                             __self->sid, checker_cmd);
              proc = run_create_process (checker_cmd, __cur_data_dir,
                                         checker_memory_limit,
                                         checker_time_limit);

              run_execute_process (proc);
              run_pwait (proc);
              INF_DEBUG_LOG ("Task %ld. Finish executing checker\n",
                             __self->sid);

              LOOP_CHECK_ACTIVE;

              /* Error while trying to execute checker */
              if (RUN_PROC_EXEC_ERROR (*proc))
                {
                  INF_DEBUG_LOG ("Task %ld. "
                                 "Fatal error duting executing checker: %s\n",
                                 __self->sid, RUN_PROC_ERROR_DESC (*proc));

                  TASK_LOG (*__self, "\n--------\n"
                                     "Fatal error: error executing checker "
                                     "at test #%d: %s.\nTesting aborted.\n",
                            i + 1, RUN_PROC_ERROR_DESC (*proc));

                  REPORT (__params, "Error executing checker at test #%d: %s.",
                          i + 1, RUN_PROC_ERROR_DESC (*proc));

                  LOOPCRASH;
                }


              /* Cecker finished by signal. */
              if (RUN_PROC_TERMINATED (*proc))
                {
                  TASK_LOG (*__self, "\n--------\n"
                                     "Fatal error: Abnormal checker "
                                     "termionation at test #%d. "
                                     "TERM signal: %d.\nTesting aborted.\n",
                            i + 1, RUN_PROC_TERMSIG (*proc));

                  REPORT (__params, "Abnormal checker termination at test #%d. "
                                    "TERM signal: %d.", i + 1,
                          RUN_PROC_TERMSIG (*proc));

                  LOOPCRASH;
                }

              INF_DEBUG_LOG ("Task %ld. "
                             "Checker finished working with exit code %d\n",
                             __self->sid, RUN_PROC_EXITCODE (*proc));

              /* Resource usage error while executing checker */
              if (RUN_PROC_MEMORYLIMIT (*proc) || RUN_PROC_TIMELIMIT (*proc))
                {
                  INF_DEBUG_LOG ("Task %ld. "
                                 "Checker's resource usage error (%s)\n",
                                 __self->sid, ((RUN_PROC_MEMORYLIMIT (*proc)) ?
                                                   ("Memory limit") :
                                                   ("Time limit")));

#ifdef __DEBUG
                  if (RUN_PROC_MEMORYLIMIT (*proc))
                    {
                      INF_DEBUG_LOG ("Task %ld. Checker's memory limit was"
                                     " %lld but %lld was used\n",
                                     __self->sid, checker_memory_limit,
                                     RUN_PROC_RSSUSAGE (*proc));
                    }
                  else
                    {
                      INF_DEBUG_LOG ("Task %ld. Checker's time limit was %lld "
                                     "but %lld was used\n", __self->sid,
                                     checker_time_limit,
                                     RUN_PROC_TIMEUSAGE (*proc));
                    }
#endif

                  TASK_LOG (*__self, "\n--------\n"
                                     "Fatal error: resource limit error while "
                                     "executing checker.\nTesting aborted.\n");
                  REPORT (__params, "Resource limit exceeded while executing "
                                    "checker at test #%d. ",
                          i + 1);

                  LOOPCRASH;
                }

              /* Overview checker's exit code */
              switch (RUN_PROC_EXITCODE (*proc))
                {
                case _OK:
                  /* Update points for task */
                  (*__points) += tests[i];
                  push_string ("OK", " ", tests_res_pchar);
                  break;
                case _WA:
                  ERR (WA, "WA");
                  break;
                case _PE:
                  ERR (PE, "PE");
                  break;
                default:
                  /* Unknown checker's exit code */
                  TASK_LOG (*__self, "\n--------\nFatal error: checker exited "
                                     "with unknown code: %d.\nBuffer from "
                                     "checker: %s\nTesting aborted.\n",
                            RUN_PROC_EXITCODE (*proc),
                            RUN_PROC_PIPEBUF (*proc));

                  REPORT (__params, "Checker exited with unknown code: %d\n"
                                    "Buffer from checker: %s",
                          i + 1, RUN_PROC_PIPEBUF (*proc));

                  LOOPCRASH;
                  break;
                }

              SAFE_FREE_PROC (proc);
            }
        }

      /* Delete input file (to reduce storaging of garbage) and */
      /* correct handling of PE */
      unlink (full_input);
      unlink (full_output);

      SAFE_FREE_PROC (proc);

      /* Log information about passed test */
      LOG_TEST;
    }

  INF_DEBUG_LOG ("Task %ld. Testing mainloop finished\n", __self->sid);

__done_:
  SAFE_FREE_PROC (proc);

  SAFE_FREE (run_solution_cmd);

  assarr_set_value (__params, "TESTS", strdup (tests_res_pchar));

  if (use_chroot)
    {
      remove_chroot_data (__cur_testing_dir);
    }

  LOOP_DONE_CHECK_ACTIVE;

  if (!CR)
    {
      if (RE) push_string ("RE", " ", __errors);
      if (ML) push_string ("ML", " ", __errors);
      if (TL) push_string ("TL", " ", __errors);
      if (WA) push_string ("WA", " ", __errors);
      if (PE) push_string ("PE", " ", __errors);

      /* If errors' string is empty, no errors were occured */
      /* in task's testing. So we can set bonus to points. */
      if (!strcmp (__errors, ""))
        {
          (*__points) += bonus;
          strcpy (__errors, "OK");
        }
    }
}

/**
 * Set task's output parameters
 *
 * @param __task - task to set parameters to
 * @param __params - params to use
 */
static void
set_output_params (wt_task_t *__task, assarr_t *__params)
{
  int i;
  char *pchar;
  flex_value_t *retprops = 0;

  /*
   * TODO: Need beautiful solution to solve this query
   */

  CONFIG_OPEN_KEY (retprops, "Server/Modules/Informatics/RetProps");
  if (!retprops)
    {
      return;
    }

  for (i = 0; i < FLEXVAL_ARRAY_LENGTH (retprops); i++)
    {
      pchar = flexval_get_array_string (retprops, i);
      if (assarr_get_value (__params, pchar))
        {
          TASK_SET_OUTPUT_PARAM (*__task, pchar,
                                 strdup (assarr_get_value (__params, pchar)));
        }
      else
        {
          TASK_SET_OUTPUT_PARAM (*__task, pchar, strdup (""));
        }
    }
}

/**
 * Print common information to task log file
 *
 * @param __self - task to print information about
 */
static void
print_common_info (wt_task_t *__self)
{
  TASK_LOG (*__self, "-- Common information:\n");
  TASK_LOG (*__self, "    Solution ID : %ld\n", __self->sid);
  TASK_LOG (*__self, "    Problem ID  : %s\n",
            (char*) assarr_get_value (__self->input_params, "PROBLEMID"));
  TASK_LOG (*__self, "    Compiler ID : %s\n",
            (char*) assarr_get_value (__self->input_params, "COMPILERID"));
  TASK_LOG (*__self, "    TESTS       : %s\n",
            (char*) assarr_get_value (__self->input_params, "TESTS"));
  TASK_LOG (*__self, "\n");
}

/**
 * Checks for required input params
 *
 * @param __self - task to check
 * @param __err - buffer to store error
 * @return TRUE on successm FALSE otherwise
 */
static BOOL
check_required_params (wt_task_t *__self, char *__err)
{
  BOOL res = TRUE;
  int i = 0;
  char *cur;

  /* Initialization */
  strcpy (__err, "");

  cur = required_params[i];
  while (cur)
    {
      if (!TASK_INPUT_PARAM (*__self, cur))
        {
          push_string (cur, ", ", __err);
          res = FALSE;
        }
      cur = required_params[++i];
    }

  return res;
}

/**
 * Unlink all unwanted testing dirs
 */
static void
unlink_unwanted_testing_dirs (void)
{
  static BOOL initialized = FALSE;
  static timeval_t last_unlink;
  timeval_t cur = now ();

  mutex_lock (unlink_mutex);
  INF_DEBUG_LOG ("Start unlinking unwanted dirs\n");

  if (!initialized)
    {
      last_unlink = now ();
      initialized = TRUE;
    }

  if (CHECK_TIME_DELTA (last_unlink, cur, unlink_interval))
    {
      char *cur_dir, full[4096];
      int to_delete = 0;
      dynastruc_t *ls;

      ls = dir_listing (testing_dir);

      to_delete = dyna_length (ls) - keep_alive_testdirs;
      if (to_delete < 0)
        {
          to_delete = 0;
        }

      DYNA_FOREACH (ls, cur_dir);
        if (!to_delete)
          {
            DYNA_BREAK;
          }

        INF_INFO ("Unlink testing dir %s\n", cur_dir);
        sprintf (full, "%s/%s", testing_dir, cur_dir);
        unlinkdir (full);
        to_delete--;
      DYNA_DONE;

      dyna_destroy (ls, dyna_deleter_free_ref_data);
      last_unlink = cur;
    }

  mutex_unlock (unlink_mutex);
  INF_DEBUG_LOG ("Unwanted dirs have been just deleted\n");
}

/**
 * Main testing thread
 */
static void
testing_thread (gpointer __data, gpointer __user_data)
{
  wt_task_t *task = __data;

  char pchar[65536];

  /* Directories for current testing stuff */
  char cur_testing_dir[4096];
  char cur_data_dir[4096];

  int points = 0, rc;
  char errors[MAX_TESTS * (MAX_ERRCODE + 1)];
  FILE *stream;

  assarr_t *all_params;

  /* Update status of the task */
  TASK_SET_STATUS (*task, TS_RUNNING);

  INF_DEBUG_LOG ("Started new thread for testing task %ld\n", task->sid);

  all_params = assarr_create ();

  /* Calculating current testing and data directories */
  sprintf (cur_testing_dir, "%s/%ld", testing_dir, task->sid);
  sprintf (cur_data_dir, "%s/%s/%s", data_dir, problems_dir,
          (char*) TASK_INPUT_PARAM (*task, "PROBLEMID"));

  /* Delete all unwanted data */
  unlinkdir (cur_testing_dir);

  /* Create global testing root. */
  /* Deny reading of this root to deny getting listing of this catalogue */
  /* to executable solutions. */
  fmkdir (testing_dir, 00773);

  /* Create current testing directory */
  fmkdir (cur_testing_dir, 00777);

  /* Some initialization */
  points = 0;
  strcpy (errors, "");

  /* Start logging */
  print_common_info (task);

  /*
   * TODO: Add TASK_SET_RESULT_MESSAGE() in case of testing crash
   */

  INF_DEBUG_LOG ("Task %ld. Check for required parameters\n", task->sid);

  /* Check for required data */
  if (!check_required_params (task, pchar))
    {
      strcpy (errors, "CR");
      TASK_LOG (*task, "\n========\n"
                       "Fatal error: Required params aren't defined: %s! "
                       "Testing aborted.\n", pchar);
      REPORT (all_params, "Required params aren't defined: %s.", pchar);
      goto __done_;
    }

  /****
   * TESTING STUFF
   */

  /*
   * Step 0: Saving solution source to file
   */

  INF_DEBUG_LOG ("Task %ld. Step 0: Save solution\n", task->sid);

  if (!save_solution (task, cur_testing_dir))
    {
      strcpy (errors, "CR");
      TASK_LOG (*task, "\n========\nFatal error: unable to save solution! "
                        "Testing aborted.\n");
      REPORT (all_params, "Error saving solution.");
      goto __done_;
    }

  /*
   * Step 1: Compiling colution
   */
  INF_DEBUG_LOG ("Task %ld. Step 1: Compile solution\n", task->sid);

  rc = compile_solution (task, cur_testing_dir, cur_data_dir, all_params);

  TESTING_CHECK_ACTIVE;

  if (rc < 0)
    {
      /* Fatal errors while compile */
      INF_DEBUG_LOG ("[EE] Task %ld. Ctirical error during solution "
                     "compilation process\n");
      points = 0;
      strcpy (errors, "CR");
      TASK_LOG (*task, "\n========\nFatal error while compiling solution. "
                       "Testing aborted.\n");
      goto __done_;
    }

  if (!rc)
    {
      /* Simple compilation error */
      points = 0;
      strcpy (errors, "CE");
      goto __done_;
    }

  /*
   * Step 2: Exec solution at all tests
   */
  testing_main_loop (task, cur_data_dir, cur_testing_dir,
                     &points, errors, all_params);

  TESTING_CHECK_ACTIVE;

__done_:

  /* Updating avaliable parameters */
  sprintf (pchar, "%d", points);
  assarr_set_value (all_params, "POINTS", strdup (pchar));
  assarr_set_value (all_params, "ERRORS", strdup (errors));

  /* Set output parameters for WebInterface */
  set_output_params (task, all_params);

  /* Some uinitialization */
  assarr_destroy (all_params, assarr_deleter_free_ref_data);

  if (strcmp (errors, "OK"))
    {
      sprintf (pchar, "Points: %d. Errors: %s", points, errors);
    }
  else
    {
      int bonus = atoi (TASK_INPUT_PARAM (*task, "BONUS"));
      sprintf (pchar, "Points: %d. Bonus: %d", points - bonus, bonus);
    }
  TASK_SET_RESULT_MESSAGE (*task, pchar);

  if (strcmp (errors, "CE") && strcmp (errors, "CR"))
    {
      TASK_LOG (*task, "\n========\nTesting completed: %s\n", pchar);
    }

  /* Save log */
  sprintf (pchar, "%s/%s", cur_testing_dir, SOLUTION_ERRORS_LOG);
  stream = fopen (pchar, "w");
  if (stream)
    {
      fprintf (stream, "%s", log_banner);
      TASK_LOG_FLUSH (*task, stream);
      fclose (stream);
    }
  chmod (pchar, 00660);

  INF_DEBUG_LOG ("Task %ld tested\n", task->sid);

  /* Now task is completely tested */
  TASK_SET_STATUS (*task, TS_FINISHED);

  goto __all_done_;

__free_:
  assarr_destroy (all_params, assarr_deleter_free_ref_data);
  TASK_SET_STATUS (*task, TS_INTERRUPTED);

__all_done_:
  unlink_unwanted_testing_dirs ();

  INF_DEBUG_LOG ("Leave testing thread\n");
}

/**
 * Read data from config file
 */
static void
read_config (void)
{
  double t = 0;
  char dummy[1024];

  INF_INT_KEY (checker_memory_limit, "Checker/Limits/RSS");

  INF_FLOAT_KEY (t, "Checker/Limits/Time");
  checker_time_limit = t*USEC_COUNT;

  INF_INT_KEY (t, "MaxThreads");
  if (t > 0) max_threads = t;

  INF_PCHAR_KEY (testing_dir, "TestingDir");
  INF_PCHAR_KEY (data_dir, "DataDir");
  INF_PCHAR_KEY (problems_dir, "ProblemsDir");

  INF_SAFE_PCHAR_KEY (source_file, "SourceFile", INFORMATICS_SOURCE);
  INF_SAFE_PCHAR_KEY (file_to_exec, "FileToExec", INFORMATICS_EXEC);

  /* Tests' files extensions  */
  INF_SAFE_PCHAR_KEY (tst_ext, "Tests/InputExtension", INFORMATICS_TSTEXT);
  INF_SAFE_PCHAR_KEY (ans_ext, "Tests/OutputExtension", INFORMATICS_ANSEXT);

  INF_SAFE_PCHAR_KEY (checker_cmd_template, "Checker/Command", "");

  INF_INT_KEY (unlink_interval, "UnlinkInterval");
  INF_INT_KEY (keep_alive_testdirs, "KeepAliveTestdirs");

  INF_PCHAR_KEY (dummy, "ChRoot");
  use_chroot = is_truth (dummy);

  /* Get security info */

  INF_SAFE_PCHAR_KEY (solution_exec_user, "SolutionExec-User", "");
  solution_exec_uid = uid_by_name (solution_exec_user);
  INF_SAFE_PCHAR_KEY (solution_exec_group, "SolutionExec-Group", "");
  solution_exec_gid = gid_by_name (solution_exec_group);
}

/**
 * Greate pool for testing threads
 */
static void
create_testing_pool (void)
{
  pool = g_thread_pool_new (testing_thread, NULL, max_threads, FALSE, NULL);
}

/******
 * User's backend
 */

/**
 * Initialize testing stuff
 *
 * @return TRUE on success, FALSE otherwise
 */
BOOL
Informatics_init_testing (void)
{
  read_config ();

  active = mutex_create ();
  unlink_mutex = mutex_create ();
  suspended = mutex_create ();

  create_testing_pool ();

  mutex_lock (active);

  return TRUE;
}

/**
 * Uninitialize testing stuff
 */
void
Informatics_done_testing (void)
{
  Informatics_stop_testing (0, 0);
  if (active)
    {
      mutex_free (active);
    }

  if (unlink_mutex)
    {
      mutex_free (unlink_mutex);
    }

  if (suspended)
    {
      mutex_free (suspended);
    }

  if (pool)
    {
      g_thread_pool_free (pool, FALSE, FALSE);
    }
}

/**
 * Wait for stopping all testing threads
 *
 * @return zero on success, non-zero otherwise
 */
int
Informatics_stop_testing (void *__unused, void *__call_unused)
{
  if (!active || !pool)
    {
      return -1;
    }

  if (mutex_trylock (active))
    {
      mutex_unlock (active);
      return -1;
    }

  /* IMHO it is the best way to wait for all threads is finished */
  mutex_unlock (active);
  g_thread_pool_free (pool, FALSE, TRUE);
  create_testing_pool ();

  return 0;
}

/**
 * Creates new testing thread
 *
 * @param __task - task to be tested
 * @param __error - error description
 * @return TRUE on success, FALSE otherwise
 */
BOOL
Informatics_start_testing_thread (wt_task_t *__task, char *__error)
{
  /* Try to lock `suspended` to make shure stuff is not suspended */
  mutex_lock (suspended);
  /* if locking is completed, unlock `suspended` */
  mutex_unlock (suspended);

  if (mutex_trylock (active))
    {
      strcpy (__error, "Testing stuff is not active");
      mutex_unlock (active);
      return FALSE;
    }

  INF_DEBUG_LOG ("Staring testing thread for task %ld\n", __task->sid);

  if (g_thread_pool_get_num_threads (pool) >= max_threads)
    {
      INF_DEBUG_LOG ("Staring testing thread for task %ld failed: "
                     "pool is full. Continue waiting in queue\n", __task->sid);
      strcpy (__error, "Testing pool is full");
      TASK_SET_FLAG (*__task, TF_KEEPINQUEUE);
      return FALSE;
    }

  INF_DEBUG_LOG ("Pushing testing thread for task %ld\n", __task->sid);
  g_thread_pool_push (pool, __task, 0);

  return TRUE;
}

/**
 * Suspend all testing
 *
 * @return zero on success, non-zero otherwise
 */
int
Informatics_SuspendTesting (void)
{
  mutex_lock (suspended);

  /* It the simpliest way to free pool */
  g_thread_pool_free (pool, FALSE, TRUE);
  create_testing_pool ();

  return 0;
}

/**
 * Resume testing
 *
 * @return zero on success, non-zero otherwise
 */
int
Informatics_ResumeTesting (void)
{
  mutex_unlock (suspended);
  return 0;
}
